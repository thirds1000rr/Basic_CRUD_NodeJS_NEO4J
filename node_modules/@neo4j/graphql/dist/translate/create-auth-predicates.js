"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAuthPredicates = void 0;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const NodeAuth_1 = require("../classes/deprecated/NodeAuth");
const create_sub_predicate_1 = require("./deprecated/auth/create-sub-predicate");
function createAuthPredicates({ entity, operations, skipRoles, skipIsAuthenticated, allow, context, bind, where, }) {
    if (!entity.auth) {
        return undefined;
    }
    /** FIXME: this is required to keep compatibility with BaseField type */
    const nodeAuth = new NodeAuth_1.NodeAuth(entity.auth);
    const authRules = nodeAuth.getRules(operations);
    const hasWhere = (rule) => !!(rule.where || rule.AND?.some(hasWhere) || rule.OR?.some(hasWhere));
    if (where && !authRules.some(hasWhere)) {
        return undefined;
    }
    const subPredicates = authRules.map((authRule) => {
        const predicate = (0, create_sub_predicate_1.createSubPredicate)({
            authRule,
            skipRoles,
            skipIsAuthenticated,
            allow,
            context,
            bind,
            where,
        });
        return predicate;
    });
    const orPredicates = cypher_builder_1.default.or(...subPredicates);
    if (!orPredicates)
        return undefined;
    const authPredicate = new cypher_builder_1.default.RawCypher((env) => {
        return orPredicates.getCypher(env);
    });
    return authPredicate;
}
exports.createAuthPredicates = createAuthPredicates;
//# sourceMappingURL=create-auth-predicates.js.map