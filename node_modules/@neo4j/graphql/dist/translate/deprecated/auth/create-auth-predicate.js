"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAuthPredicate = void 0;
const cypher_builder_1 = __importDefault(require("@neo4j/cypher-builder"));
const classes_1 = require("../../../classes");
const context_parser_1 = __importDefault(require("../../../utils/context-parser"));
const join_predicates_1 = require("../../../utils/join-predicates");
const utils_1 = require("../../../utils/utils");
const create_auth_field_1 = require("./create-auth-field");
const create_relationship_predicate_1 = require("./create-relationship-predicate");
function createAuthPredicate({ rule, node, nodeRef, context, kind, }) {
    if (!rule[kind]) {
        return undefined;
    }
    const { allowUnauthenticated } = rule;
    const predicates = [];
    Object.entries(rule[kind]).forEach(([key, value]) => {
        if ((0, join_predicates_1.isPredicateJoin)(key)) {
            const inner = [];
            value.forEach((v) => {
                const authPredicate = createAuthPredicate({
                    rule: {
                        [kind]: v,
                        allowUnauthenticated,
                    },
                    nodeRef,
                    node,
                    context,
                    kind,
                });
                if (authPredicate) {
                    inner.push(authPredicate);
                }
            });
            let operator;
            if (key === "AND") {
                operator = cypher_builder_1.default.and(...inner);
            }
            else if (key === "OR") {
                operator = cypher_builder_1.default.or(...inner);
            }
            if (operator)
                predicates.push(operator);
        }
        const authableField = node.authableFields.find((field) => field.fieldName === key);
        if (authableField) {
            const jwtPath = (0, utils_1.isString)(value) ? context_parser_1.default.parseTag(value, "jwt") : undefined;
            let ctxPath = (0, utils_1.isString)(value) ? context_parser_1.default.parseTag(value, "context") : undefined;
            let paramValue = value;
            if (jwtPath)
                ctxPath = `jwt.${jwtPath}`;
            if (ctxPath) {
                paramValue = context_parser_1.default.getProperty(ctxPath, context);
            }
            if (paramValue === undefined && allowUnauthenticated !== true) {
                throw new classes_1.Neo4jGraphQLAuthenticationError("Unauthenticated");
            }
            const fieldPredicate = (0, create_auth_field_1.createAuthField)({
                param: new cypher_builder_1.default.Param(paramValue),
                key,
                node,
                elementRef: nodeRef,
            });
            predicates.push(fieldPredicate);
        }
        const relationField = node.relationFields.find((x) => key === x.fieldName);
        if (relationField) {
            const refNode = context.nodes.find((x) => x.name === relationField.typeMeta.name);
            const relationshipNodeRef = new cypher_builder_1.default.Node({
                labels: refNode.getLabels(context),
            });
            Object.entries(value).forEach(([k, v]) => {
                const authPredicate = createAuthPredicate({
                    node: refNode,
                    context,
                    nodeRef: relationshipNodeRef,
                    rule: {
                        [kind]: { [k]: v },
                        allowUnauthenticated,
                    },
                    kind,
                });
                if (!authPredicate)
                    throw new Error("Invalid predicate");
                const relationshipPredicate = (0, create_relationship_predicate_1.createRelationshipPredicate)({
                    targetNodeRef: relationshipNodeRef,
                    nodeRef,
                    relationField,
                    authPredicate,
                    kind,
                    context,
                });
                predicates.push(relationshipPredicate);
            });
        }
    });
    return cypher_builder_1.default.and(...predicates);
}
exports.createAuthPredicate = createAuthPredicate;
//# sourceMappingURL=create-auth-predicate.js.map