"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSubscriptionConnectionWhereType = exports.generateSubscriptionWhereType = void 0;
const to_compose_1 = require("../to-compose");
const upper_first_1 = require("../../utils/upper-first");
const isEmptyObject = (obj) => !Object.keys(obj).length;
function generateSubscriptionWhereType(node, schemaComposer) {
    const typeName = node.name;
    if (schemaComposer.has(`${node.name}SubscriptionWhere`)) {
        return schemaComposer.getITC(`${node.name}SubscriptionWhere`);
    }
    const whereFields = (0, to_compose_1.objectFieldsToSubscriptionsWhereInputFields)(typeName, [
        ...node.primitiveFields,
        ...node.enumFields,
        ...node.scalarFields,
        ...node.temporalFields,
        ...node.pointFields,
    ]);
    if (isEmptyObject(whereFields)) {
        return;
    }
    return schemaComposer.createInputTC({
        name: `${node.name}SubscriptionWhere`,
        fields: whereFields,
    });
}
exports.generateSubscriptionWhereType = generateSubscriptionWhereType;
function generateSubscriptionConnectionWhereType({ node, schemaComposer, relationshipFields, interfaceCommonFields, }) {
    const fieldName = node.subscriptionEventPayloadFieldNames.create_relationship;
    const typeName = node.name;
    const connectedRelationship = getRelationshipConnectionWhereTypes({
        node,
        schemaComposer,
        relationshipFields,
        interfaceCommonFields,
    });
    const isConnectedNodeTypeNotExcluded = schemaComposer.has(`${typeName}SubscriptionWhere`);
    if (!isConnectedNodeTypeNotExcluded && !connectedRelationship) {
        return;
    }
    return {
        created: schemaComposer.createInputTC({
            name: `${typeName}RelationshipCreatedSubscriptionWhere`,
            fields: {
                ...(isConnectedNodeTypeNotExcluded && {
                    [fieldName]: schemaComposer.getITC(`${typeName}SubscriptionWhere`),
                }),
                ...(connectedRelationship && { createdRelationship: connectedRelationship }),
            },
        }),
        deleted: schemaComposer.createInputTC({
            name: `${typeName}RelationshipDeletedSubscriptionWhere`,
            fields: {
                ...(isConnectedNodeTypeNotExcluded && {
                    [fieldName]: schemaComposer.getITC(`${typeName}SubscriptionWhere`),
                }),
                ...(connectedRelationship && { deletedRelationship: connectedRelationship }),
            },
        }),
    };
}
exports.generateSubscriptionConnectionWhereType = generateSubscriptionConnectionWhereType;
function getRelationshipConnectionWhereTypes({ node, schemaComposer, relationshipFields, interfaceCommonFields, }) {
    const { name, relationFields } = node;
    const relationsFieldInputWhereTypeFields = relationFields.reduce((acc, rf) => {
        const { fieldName } = rf;
        const nodeRelationPrefix = `${name}${(0, upper_first_1.upperFirst)(fieldName)}`;
        const fields = makeNodeRelationFields({
            relationField: rf,
            schemaComposer,
            interfaceCommonFields,
            relationshipFields,
            nodeRelationPrefix,
        });
        if (!fields) {
            return acc;
        }
        const relationFieldInputWhereType = schemaComposer.createInputTC({
            name: `${nodeRelationPrefix}RelationshipSubscriptionWhere`,
            fields,
        });
        acc[fieldName] = relationFieldInputWhereType;
        return acc;
    }, {});
    if (isEmptyObject(relationsFieldInputWhereTypeFields)) {
        return;
    }
    const relationsFieldInputWhereType = schemaComposer.createInputTC({
        name: `${name}RelationshipsSubscriptionWhere`,
        fields: relationsFieldInputWhereTypeFields,
    });
    return relationsFieldInputWhereType;
}
function makeNodeRelationFields({ relationField, schemaComposer, interfaceCommonFields, relationshipFields, nodeRelationPrefix, }) {
    const edgeType = makeRelationshipWhereType({
        relationshipFields,
        schemaComposer,
        relationField,
    });
    const unionNodeTypes = relationField.union?.nodes;
    if (unionNodeTypes) {
        return makeRelationshipToUnionTypeWhereType({ unionNodeTypes, schemaComposer, nodeRelationPrefix, edgeType });
    }
    const interfaceNodeTypes = relationField.interface?.implementations;
    if (interfaceNodeTypes) {
        const interfaceNodeTypeName = relationField.typeMeta.name;
        const interfaceCommonFieldsOnImplementations = interfaceCommonFields.get(interfaceNodeTypeName);
        return makeRelationshipToInterfaceTypeWhereType({
            interfaceNodeTypeName,
            schemaComposer,
            interfaceNodeTypes,
            interfaceCommonFieldsOnImplementations,
            edgeType,
        });
    }
    return makeRelationshipToConcreteTypeWhereType({ relationField, edgeType, schemaComposer });
}
function makeRelationshipWhereType({ relationshipFields, schemaComposer, relationField, }) {
    const relationProperties = relationshipFields.get(relationField.properties || "");
    if (!relationProperties) {
        return undefined;
    }
    return schemaComposer.getOrCreateITC(`${relationField.properties}SubscriptionWhere`, (tc) => tc.addFields((0, to_compose_1.objectFieldsToSubscriptionsWhereInputFields)(relationField.properties, [
        ...relationProperties.primitiveFields,
        ...relationProperties.enumFields,
        ...relationProperties.scalarFields,
        ...relationProperties.temporalFields,
    ])));
}
function makeRelationshipToConcreteTypeWhereType({ relationField, edgeType, schemaComposer, }) {
    const nodeTypeName = relationField.typeMeta.name;
    const nodeExists = schemaComposer.has(`${nodeTypeName}SubscriptionWhere`);
    if (!nodeExists && !edgeType) {
        return undefined;
    }
    return {
        ...(nodeExists && { node: `${nodeTypeName}SubscriptionWhere` }),
        ...(edgeType && { edge: edgeType }),
    };
}
function makeRelationshipToUnionTypeWhereType({ unionNodeTypes, schemaComposer, nodeRelationPrefix, edgeType, }) {
    const unionTypes = unionNodeTypes.reduce((acc, concreteTypeName) => {
        const nodeExists = schemaComposer.has(`${concreteTypeName}SubscriptionWhere`);
        if (!nodeExists && !edgeType) {
            return acc;
        }
        acc[concreteTypeName] = schemaComposer.getOrCreateITC(`${nodeRelationPrefix}${concreteTypeName}SubscriptionWhere`, (tc) => tc.addFields({
            ...(nodeExists && { node: `${concreteTypeName}SubscriptionWhere` }),
            ...(edgeType && { edge: edgeType }),
        }));
        return acc;
    }, {});
    if (isEmptyObject(unionTypes)) {
        return;
    }
    return unionTypes;
}
function makeRelationshipToInterfaceTypeWhereType({ interfaceNodeTypeName, schemaComposer, interfaceNodeTypes, interfaceCommonFieldsOnImplementations, edgeType, }) {
    let interfaceImplementationsType, interfaceNodeType = undefined;
    const implementationsFields = interfaceNodeTypes.reduce((acc, concreteTypeName) => {
        if (schemaComposer.has(`${concreteTypeName}SubscriptionWhere`)) {
            acc[concreteTypeName] = `${concreteTypeName}SubscriptionWhere`;
        }
        return acc;
    }, {});
    if (!isEmptyObject(implementationsFields)) {
        interfaceImplementationsType = schemaComposer.getOrCreateITC(`${interfaceNodeTypeName}ImplementationsSubscriptionWhere`, (tc) => tc.addFields(implementationsFields));
    }
    if (interfaceImplementationsType || interfaceCommonFieldsOnImplementations) {
        const interfaceFields = {
            ...(interfaceImplementationsType && { _on: interfaceImplementationsType }),
            ...(interfaceCommonFieldsOnImplementations &&
                (0, to_compose_1.objectFieldsToSubscriptionsWhereInputFields)(interfaceNodeTypeName, [
                    ...interfaceCommonFieldsOnImplementations.primitiveFields,
                    ...interfaceCommonFieldsOnImplementations.enumFields,
                    ...interfaceCommonFieldsOnImplementations.scalarFields,
                    ...interfaceCommonFieldsOnImplementations.temporalFields,
                    ...interfaceCommonFieldsOnImplementations.pointFields,
                ])),
        };
        if (!isEmptyObject(interfaceFields)) {
            interfaceNodeType = schemaComposer.getOrCreateITC(`${interfaceNodeTypeName}SubscriptionWhere`, (tc) => tc.addFields(interfaceFields));
        }
    }
    if (!interfaceNodeType && !edgeType) {
        return;
    }
    return {
        ...(interfaceNodeType && { node: interfaceNodeType }),
        ...(edgeType && { edge: edgeType }),
    };
}
//# sourceMappingURL=generate-subscription-where-type.js.map